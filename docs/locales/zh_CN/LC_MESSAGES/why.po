# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../why.md:1
msgid "Why not…"
msgstr "为什么不 ..."

#: ../../why.md:3
msgid ""
"If you'd like third party's account why *attrs* is great, have a look at "
"Glyph's [*The One Python Library Everyone "
"Needs*](https://glyph.twistedmatrix.com/2016/08/attrs.html). It predates "
"type annotations and hence Data Classes, but it masterfully illustrates "
"the appeal of class-building packages."
msgstr ""
"如果你想知道为什么 *attrs* 很棒，可以看看 [*The One Python Library Everyone Needs*](https://glyph.twistedmatrix.com/2016/08/attrs.html)。"
"它早于类型注释，因此也早于数据类，但它巧妙地说明了类构建包的吸引力。"

#: ../../why.md:7
msgid "… Data Classes?"
msgstr "... 数据类？"

#: ../../why.md:9
msgid ""
"{pep}`557` added Data Classes to [Python "
"3.7](https://docs.python.org/3.7/whatsnew/3.7.html#dataclasses) that "
"resemble *attrs* in many ways."
msgstr ""

#: ../../why.md:11
msgid ""
"They are the result of the Python community's "
"[wish](https://mail.python.org/pipermail/python-"
"ideas/2017-May/045618.html) to have an easier way to write classes in the"
" standard library that doesn't carry the problems of `namedtuple`s. To "
"that end, *attrs* and its developers were involved in the PEP process and"
" while we may disagree with some minor decisions that have been made, "
"it's a fine library and if it stops you from abusing `namedtuple`s, they "
"are a huge win."
msgstr ""

#: ../../why.md:14
msgid ""
"Nevertheless, there are still reasons to prefer *attrs* over Data "
"Classes. Whether they're relevant to *you* depends on your circumstances:"
msgstr ""

#: ../../why.md:17
msgid ""
"Data Classes are *intentionally* less powerful than *attrs*. There is a "
"long list of features that were sacrificed for the sake of simplicity and"
" while the most obvious ones are validators, converters, {ref}`equality "
"customization <custom-comparison>`, or {doc}`extensibility <extending>` "
"in general, it permeates throughout all APIs."
msgstr ""

#: ../../why.md:20
msgid ""
"On the other hand, Data Classes currently do not offer any significant "
"feature that *attrs* doesn't already have."
msgstr ""

#: ../../why.md:22
msgid "*attrs* supports all mainstream Python versions including PyPy."
msgstr ""

#: ../../why.md:24
msgid "*attrs* doesn't force type annotations on you if you don't like them."
msgstr ""

#: ../../why.md:26
msgid ""
"But since it **also** supports typing, it's the best way to embrace type "
"hints *gradually*, too."
msgstr ""

#: ../../why.md:28
msgid ""
"While Data Classes are implementing features from *attrs* every now and "
"then, their presence is dependent on the Python version, not the package "
"version. For example, support for `__slots__` has only been added in "
"Python 3.10, but it doesn’t do cell rewriting and therefore doesn’t "
"support bare calls to `super()`. This may or may not be fixed in later "
"Python releases, but handling all these differences is especially painful"
" for PyPI packages that support multiple Python versions. And of course, "
"this includes possible implementation bugs."
msgstr ""

#: ../../why.md:33
msgid ""
"*attrs* can and will move faster. We are not bound to any release "
"schedules and we have a clear deprecation policy."
msgstr ""

#: ../../why.md:36
msgid ""
"One of the [reasons](https://peps.python.org/pep-0557/#why-not-just-use-"
"attrs) to not vendor *attrs* in the standard library was to not impede "
"*attrs*'s future development."
msgstr ""

#: ../../why.md:38
msgid ""
"One way to think about *attrs* vs Data Classes is that *attrs* is a "
"fully-fledged toolkit to write powerful classes while Data Classes are an"
" easy way to get a class with some attributes. Basically what *attrs* was"
" in 2015."
msgstr ""

#: ../../why.md:42
msgid "… pydantic?"
msgstr ""

#: ../../why.md:44
msgid ""
"*pydantic* is first and foremost a *data validation library*. As such, it"
" is a capable complement to class building libraries like *attrs* (or "
"Data Classes!) for parsing and validating untrusted data."
msgstr ""

#: ../../why.md:47
msgid ""
"However, as convenient as it might be, using it for your business or data"
" layer [is problematic in several ways](https://threeofwands.com/why-i"
"-use-attrs-instead-of-pydantic/): Is it really necessary to re-validate "
"all your objects while reading them from a trusted database? In the "
"parlance of [*Form, Command, and Model "
"Validation*](https://verraes.net/2015/02/form-command-model-validation/),"
" *pydantic* is the right tool for *Commands*."
msgstr ""

#: ../../why.md:51
msgid ""
"[*Separation of "
"concerns*](https://en.wikipedia.org/wiki/Separation_of_concerns) feels "
"tedious at times, but it's one of those things that you get to appreciate"
" once you've shot your own foot often enough."
msgstr ""

#: ../../why.md:54
msgid "… namedtuples?"
msgstr ""

#: ../../why.md:56
msgid ""
"{obj}`collections.namedtuple`s are tuples with names, not "
"classes.[^history] Since writing classes is tiresome in Python, every now"
" and then someone discovers all the typing they could save and gets "
"really excited. However, that convenience comes at a price."
msgstr ""

#: ../../why.md:60
msgid ""
"The most obvious difference between `namedtuple`s and *attrs*-based "
"classes is that the latter are type-sensitive:"
msgstr ""

#: ../../why.md:74
msgid ""
"…while a `namedtuple` is *intentionally* [behaving like a "
"tuple](https://docs.python.org/3/tutorial/datastructures.html#tuples-and-"
"sequences) which means the type of a tuple is *ignored*:"
msgstr ""

#: ../../why.md:86
msgid "Other often surprising behaviors include:"
msgstr ""

#: ../../why.md:88
msgid ""
"Since they are a subclass of tuples, `namedtuple`s have a length and are "
"both iterable and indexable. That's not what you'd expect from a class "
"and is likely to shadow subtle typo bugs."
msgstr ""

#: ../../why.md:91
msgid ""
"Iterability also implies that it's easy to accidentally unpack a "
"`namedtuple` which leads to hard-to-find bugs.[^iter]"
msgstr ""

#: ../../why.md:93
msgid ""
"`namedtuple`s have their methods *on your instances* whether you like it "
"or not.[^pollution]"
msgstr ""

#: ../../why.md:95
msgid ""
"`namedtuple`s are *always* immutable. Not only does that mean that you "
"can't decide for yourself whether your instances should be immutable or "
"not, it also means that if you want to influence your class' "
"initialization (validation? default values?), you have to implement "
"{meth}`__new__() <object.__new__>` which is a particularly hacky and "
"error-prone requirement for a very common problem.[^immutable]"
msgstr ""

#: ../../why.md:98
msgid ""
"To attach methods to a `namedtuple` you have to subclass it. And if you "
"follow the standard library documentation's recommendation of:"
msgstr ""

#: ../../why.md:106
msgid ""
"you end up with a class that has *two* `Point`s in its {attr}`__mro__ "
"<class.__mro__>`: `[<class 'point.Point'>, <class 'point.Point'>, <type "
"'tuple'>, <type 'object'>]`."
msgstr ""

#: ../../why.md:108
msgid ""
"That's not only confusing, it also has very practical consequences: for "
"example if you create documentation that includes class hierarchies like "
"*[*Sphinx*'s autodoc](https://www.sphinx-"
"doc.org/en/stable/usage/extensions/autodoc.html) with `show-inheritance`."
" Again: common problem, hacky solution with confusing fallout."
msgstr ""

#: ../../why.md:112
msgid ""
"All these things make `namedtuple`s a particularly poor choice for public"
" APIs because all your objects are irrevocably tainted. With *attrs* your"
" users won't notice a difference because it creates regular, well-behaved"
" classes."
msgstr ""

#: ../../why.md:115 ../../why.md:291
msgid "Summary"
msgstr ""

#: ../../why.md:116
msgid ""
"If you want a *tuple with names*, by all means: go for a "
"`namedtuple`.[^perf] But if you want a class with methods, you're doing "
"yourself a disservice by relying on a pile of hacks that requires you to "
"employ even more hacks as your requirements expand."
msgstr ""

#: ../../why.md:119
msgid ""
"Other than that, *attrs* also adds nifty features like validators, "
"converters, and (mutable!) default values."
msgstr ""

#: ../../why.md:139
msgid "… tuples?"
msgstr ""

#: ../../why.md:141
msgid "Readability"
msgstr ""

#: ../../why.md:143
msgid "What makes more sense while debugging:"
msgstr ""

#: ../../why.md:149 ../../why.md:163
msgid "or:"
msgstr ""

#: ../../why.md:155 ../../why.md:169
msgid "?"
msgstr ""

#: ../../why.md:157
msgid "Let's add even more ambiguity:"
msgstr ""

#: ../../why.md:171
msgid ""
"Why would you want to write `customer[2]` instead of "
"`customer.first_name`?"
msgstr ""

#: ../../why.md:173
msgid ""
"Don't get me started when you add nesting. If you've never run into "
"mysterious tuples you had no idea what the hell they meant while "
"debugging, you're much smarter than yours truly."
msgstr ""

#: ../../why.md:176
msgid ""
"Using proper classes with names and types makes program code much more "
"readable and [comprehensible](https://arxiv.org/pdf/1304.5257.pdf). "
"Especially when trying to grok a new piece of software or returning to "
"old code after several months."
msgstr ""

#: ../../why.md:180
msgid "Extendability"
msgstr ""

#: ../../why.md:182
msgid ""
"Imagine you have a function that takes or returns a tuple. Especially if "
"you use tuple unpacking (eg. `x, y = get_point()`), adding additional "
"data means that you have to change the invocation of that function "
"*everywhere*."
msgstr ""

#: ../../why.md:185
msgid ""
"Adding an attribute to a class concerns only those who actually care "
"about that attribute."
msgstr ""

#: ../../why.md:188
msgid "… dicts?"
msgstr ""

#: ../../why.md:190
msgid "Dictionaries are not for fixed fields."
msgstr ""

#: ../../why.md:192
msgid ""
"If you have a dict, it maps something to something else. You should be "
"able to add and remove values."
msgstr ""

#: ../../why.md:195
msgid ""
"*attrs* lets you be specific about those expectations; a dictionary does "
"not. It gives you a named entity (the class) in your code, which lets you"
" explain in other places whether you take a parameter of that class or "
"return a value of that class."
msgstr ""

#: ../../why.md:198
msgid ""
"In other words: if your dict has a fixed and known set of keys, it is an "
"object, not a hash. So if you never iterate over the keys of a dict, you "
"should use a proper class."
msgstr ""

#: ../../why.md:202
msgid "… hand-written classes?"
msgstr ""

#: ../../why.md:204
msgid ""
"While we're fans of all things artisanal, writing the same nine methods "
"again and again doesn't qualify. I usually manage to get some typos "
"inside and there's simply more code that can break and thus has to be "
"tested."
msgstr ""

#: ../../why.md:207
msgid "To bring it into perspective, the equivalent of"
msgstr ""

#: ../../why.md:218
msgid "is roughly"
msgstr ""

#: ../../why.md:272
msgid ""
"which is quite a mouthful and it doesn't even use any of *attrs*'s more "
"advanced features like validators or defaults values. Also: no tests "
"whatsoever. And who will guarantee you, that you don't accidentally flip "
"the `<` in your tenth implementation of `__gt__`?"
msgstr ""

#: ../../why.md:276
msgid ""
"It also should be noted that *attrs* is not an all-or-nothing solution. "
"You can freely choose which features you want and disable those that you "
"want more control over:"
msgstr ""

#: ../../why.md:292
msgid "If you don't care and like typing, we're not gonna stop you."
msgstr ""

#: ../../why.md:294
msgid ""
"However it takes a lot of bias and determined rationalization to claim "
"that *attrs* raises the mental burden on a project given how difficult it"
" is to find the important bits in a hand-written class and how annoying "
"it is to ensure you've copy-pasted your code correctly over all your "
"classes."
msgstr ""

#: ../../why.md:296
msgid ""
"In any case, if you ever get sick of the repetitiveness and drowning "
"important code in a sea of boilerplate, *attrs* will be waiting for you."
msgstr ""

#: ../../why.md:122
msgid ""
"The word is that `namedtuple`s were added to the Python standard library "
"as a way to make tuples in return values more readable. And indeed that "
"is something you see throughout the standard library."
msgstr ""

#: ../../why.md:125
msgid ""
"Looking at what the makers of `namedtuple`s use it for themselves is a "
"good guideline for deciding on your own use cases."
msgstr ""

#: ../../why.md:131
msgid ""
"{func}`attrs.astuple` can be used to get that behavior in *attrs* on "
"*explicit demand*."
msgstr ""

#: ../../why.md:127
msgid ""
"*attrs* only adds a single attribute: `__attrs_attrs__` for "
"introspection. All helpers are functions in the `attr` package. Since "
"they take the instance as first argument, you can easily attach them to "
"your classes under a name of your own choice."
msgstr ""

#: ../../why.md:133
msgid "*attrs* offers *optional* immutability through the `frozen` keyword."
msgstr ""

#: ../../why.md:135
msgid ""
"Although *attrs* would serve you just as well! Since both employ the same"
" method of writing and compiling Python code for you, the performance "
"penalty is negligible at worst and in some cases *attrs* is even faster "
"if you use `slots=True` (which is generally a good idea anyway)."
msgstr ""

