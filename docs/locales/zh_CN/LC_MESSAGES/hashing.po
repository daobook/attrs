# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../hashing.md:1
msgid "Hashing"
msgstr "哈希"

#: ../../hashing.md:3
msgid "Hash Method Generation"
msgstr "哈希方法生成"

#: ../../hashing.md:6
msgid ""
"The overarching theme is to never set the `@attrs.define(unsafe_hash=X)` "
"parameter yourself. Leave it at `None` which means that *attrs* will do "
"the right thing for you, depending on the other parameters:"
msgstr ""
"最重要的主题是永远不要自己设置 `@attrs.define(unsafe_hash=X)` 参数。"
"保留为 `None`，这意味着 *attrs* 将为您做正确的事情，这取决于其他参数："

#: ../../hashing.md:9
msgid "If you want to make objects hashable by value: use `@define(frozen=True)`."
msgstr "如果你想让对象按值哈希：使用 `@define(frozen=True)`。"

#: ../../hashing.md:10
msgid ""
"If you want hashing and equality by object identity: use "
"`@define(eq=False)`"
msgstr ""
"如果你想通过对象标识来哈希和相等：使用 `@define(eq=False)`"

#: ../../hashing.md:12
msgid ""
"Setting `unsafe_hash` yourself can have unexpected consequences so we "
"recommend to tinker with it only if you know exactly what you're doing."
msgstr ""
"自己设置 `unsafe_hash` 可能会产生意想不到的后果，所以建议只有在你确切知道自己在做什么的情况下才修改它。"

#: ../../hashing.md:15
msgid ""
"Under certain circumstances, it's necessary for objects to be *hashable*."
" For example if you want to put them into a {class}`set` or if you want "
"to use them as keys in a {class}`dict`."
msgstr ""

#: ../../hashing.md:18
msgid ""
"The *hash* of an object is an integer that represents the contents of an "
"object. It can be obtained by calling {func}`hash` on an object and is "
"implemented by writing a `__hash__` method for your class."
msgstr ""

#: ../../hashing.md:21
msgid ""
"*attrs* will happily write a `__hash__` method for you [^fn1], however it"
" will *not* do so by default. Because according to the "
"[definition](https://docs.python.org/3/glossary.html#term-hashable) from "
"the official Python docs, the returned hash has to fulfill certain "
"constraints:"
msgstr ""

#: ../../hashing.md:26
msgid ""
"Two objects that are equal, **must** have the same hash. This means that "
"if `x == y`, it *must* follow that `hash(x) == hash(y)`."
msgstr ""

#: ../../hashing.md:29
msgid ""
"By default, Python classes are compared *and* hashed by their `id`. That "
"means that every instance of a class has a different hash, no matter what"
" attributes it carries."
msgstr ""

#: ../../hashing.md:32
msgid ""
"It follows that the moment you (or *attrs*) change the way equality is "
"handled by implementing `__eq__` which is based on attribute values, this"
" constraint is broken. For that reason Python 3 will make a class that "
"has customized equality unhashable. Python 2 on the other hand will "
"happily let you shoot your foot off. Unfortunately, *attrs* still mimics "
"(otherwise unsupported) Python 2's behavior for backward-compatibility "
"reasons if you set `unsafe_hash=False`."
msgstr ""

#: ../../hashing.md:37
msgid ""
"The *correct way* to achieve hashing by id is to set `@define(eq=False)`."
" Setting `@define(unsafe_hash=False)` (which implies `eq=True`) is almost"
" certainly a *bug*."
msgstr ""

#: ../../hashing.md:41
msgid ""
"Be careful when subclassing! Setting `eq=False` on a class whose base "
"class has a non-default `__hash__` method will *not* make *attrs* remove "
"that `__hash__` for you."
msgstr ""

#: ../../hashing.md:44
msgid ""
"It is part of *attrs*'s philosophy to only *add* to classes so you have "
"the freedom to customize your classes as you wish. So if you want to *get"
" rid* of methods, you'll have to do it by hand."
msgstr ""

#: ../../hashing.md:47
msgid ""
"The easiest way to reset `__hash__` on a class is adding `__hash__ = "
"object.__hash__` in the class body."
msgstr ""

#: ../../hashing.md:50
msgid "If two objects are not equal, their hash **should** be different."
msgstr ""

#: ../../hashing.md:52
msgid ""
"While this isn't a requirement from a standpoint of correctness, sets and"
" dicts become less effective if there are a lot of identical hashes. The "
"worst case is when all objects have the same hash which turns a set into "
"a list."
msgstr ""

#: ../../hashing.md:55
msgid "The hash of an object **must not** change."
msgstr ""

#: ../../hashing.md:57
msgid ""
"If you create a class with `@define(frozen=True)` this is fulfilled by "
"definition, therefore *attrs* will write a `__hash__` function for you "
"automatically. You can also force it to write one with `unsafe_hash=True`"
" but then it's *your* responsibility to make sure that the object is not "
"mutated."
msgstr ""

#: ../../hashing.md:60
msgid ""
"This point is the reason why mutable structures like lists, dictionaries,"
" or sets aren't hashable while immutable ones like tuples or `frozenset`s"
" are: point 1 and 2 require that the hash changes with the contents but "
"point 3 forbids it."
msgstr ""

#: ../../hashing.md:63
msgid ""
"For a more thorough explanation of this topic, please refer to this blog "
"post: [*Python Hashes and Equality*](https://hynek.me/articles/hashes-"
"and-equality/)."
msgstr ""

#: ../../hashing.md:66
msgid ""
"Please note that the `unsafe_hash` argument's original name was `hash` "
"but was changed to conform with {pep}`681` in 22.2.0. The old argument "
"name is still around and will **not** be removed -- but setting "
"`unsafe_hash` takes precedence over `hash`. The field-level argument is "
"still called `hash` and will remain so."
msgstr ""

#: ../../hashing.md:72
msgid "Hashing and Mutability"
msgstr ""

#: ../../hashing.md:74
msgid ""
"Changing any field involved in hash code computation after the first call"
" to `__hash__` (typically this would be after its insertion into a hash-"
"based collection) can result in silent bugs. Therefore, it is strongly "
"recommended that hashable classes be `frozen`. Beware, however, that this"
" is not a complete guarantee of safety: if a field points to an object "
"and that object is mutated, the hash code may change, but `frozen` will "
"not protect you."
msgstr ""

#: ../../hashing.md:80
msgid "Hash Code Caching"
msgstr ""

#: ../../hashing.md:82
msgid ""
"Some objects have hash codes which are expensive to compute. If such "
"objects are to be stored in hash-based collections, it can be useful to "
"compute the hash codes only once and then store the result on the object "
"to make future hash code requests fast. To enable caching of hash codes, "
"pass `@define(cache_hash=True)`. This may only be done if *attrs* is "
"already generating a hash function for the object."
msgstr ""

#: ../../hashing.md:24
msgid ""
"The hash is computed by hashing a tuple that consists of a unique id for "
"the class plus all attribute values."
msgstr ""

