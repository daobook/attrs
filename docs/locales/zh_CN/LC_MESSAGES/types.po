# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../types.md:1
msgid "Type Annotations"
msgstr "类型注解"

#: ../../types.md:3
msgid ""
"*attrs* comes with first class support for type annotations for both "
"Python 3.6 ({pep}`526`) and legacy syntax."
msgstr ""
"*attrs* 附带了对 Python 3.6 ({pep}`526`)和遗留语法的类型注释的第一类支持。"

#: ../../types.md:5
msgid ""
"However they will forever remain *optional*, therefore the example from "
"the README could also be written as:"
msgstr ""
"然而，它们永远是 *可选的*，因此 README 中的例子也可以写成："

#: ../../types.md:20
msgid ""
"You can choose freely between the approaches, but please remember that if"
" you choose to use type annotations, you **must** annotate **all** "
"attributes!"
msgstr ""
"您可以在这些方法中自由选择，但是请记住，如果您选择使用类型注解，则必须注解所有属性！"

#: ../../types.md:24
msgid ""
"Even when going all-in on type annotations, you will need "
"{func}`attrs.field` for some advanced features though."
msgstr ""
"即使完全使用类型注释，也需要 {func}`attrs.field` 来实现一些高级特性。"

#: ../../types.md:26
msgid ""
"One of those features are the decorator-based features like defaults. "
"It's important to remember that *attrs* doesn't do any magic behind your "
"back. All the decorators are implemented using an object that is returned"
" by the call to {func}`attrs.field`."
msgstr ""
"其中一个特性是基于装饰器的特性，如默认值。重要的是要记住，*attrs* 不会在你背后施任何魔法。所有装饰器都是使用调用 {func}`attrs.field` 返回的对象实现的。"

#: ../../types.md:30
msgid ""
"Attributes that only carry a class annotation do not have that object so "
"trying to call a method on it will inevitably fail."
msgstr ""
"只带有类注释的属性没有该对象，因此试图对其调用方法将不可避免地失败。"

#: ../../types.md:34
msgid ""
"Please note that types -- regardless how added -- are *only metadata* "
"that can be queried from the class and they aren't used for anything out "
"of the box!"
msgstr ""
"请注意，类型(无论如何添加)只是可以从类中查询的元数据，它们不能用于任何开箱即用的东西！"

#: ../../types.md:36
msgid ""
"Because Python does not allow references to a class object before the "
"class is defined, types may be defined as string literals, so-called "
"*forward references* ({pep}`526`). You can enable this automatically for "
"a whole module by using `from __future__ import annotations` ({pep}`563`)"
" as of Python 3.7. In this case *attrs* simply puts these string literals"
" into the `type` attributes. If you need to resolve these to real types, "
"you can call {func}`attrs.resolve_types` which will update the attribute "
"in place."
msgstr ""
"因为 Python 不允许在定义类之前引用类对象，所以类型可以定义为字符串字面量，即所谓的 *前向引用* （forward references）({pep}`526`)。"
"从 Python 3.7 开始，您可以使用 `from __future__ import annotations` ({pep}`563`)为整个模块自动启用此功能。"
"在本例中，*attrs* 只是将这些字符串字面量放入类型属性中。"
"如果需要将这些解析为真实类型，可以调用 {func}`attrs.resolve_types`，它将在适当的位置更新属性。"

#: ../../types.md:42
msgid ""
"In practice though, types show their biggest usefulness in combination "
"with tools like [*Mypy*], [*pytype*], or [*Pyright*] that have dedicated "
"support for *attrs* classes."
msgstr ""
"但在实践中，类型在与 [*Mypy*], [*pytype*] 或  [*Pyright*] 等工具结合使用时表现出最大的用处，这些工具专门支持 *attrs* 类。"

#: ../../types.md:44
msgid ""
"The addition of static types is certainly one of the most exciting "
"features in the Python ecosystem and helps you write *correct* and "
"*verified self-documenting* code."
msgstr ""
"静态类型的添加无疑是 Python 生态系统中最令人兴奋的特性之一，它可以帮助您编写正确且经过验证的 self-documenting 代码。"

#: ../../types.md:46
msgid ""
"If you don't know where to start, Carl Meyer gave a great talk on [*Type-"
"checked Python in the Real "
"World*](https://www.youtube.com/watch?v=pMgmKJyWKn8) at PyCon US 2018 "
"that will help you to get started in no time."
msgstr ""
"如果你不知道从哪里开始，Carl Meyer 在 PyCon US 2018 上做了关于[真实世界中的类型检查](https://www.youtube.com/watch?v=pMgmKJyWKn8) Python 的演讲，这将帮助你立即开始。"

#: ../../types.md:49
msgid "Mypy"
msgstr ""

#: ../../types.md:51
msgid ""
"While having a nice syntax for type metadata is great, it's even greater "
"that [*Mypy*] as of 0.570 ships with a dedicated *attrs* plugin which "
"allows you to statically check your code."
msgstr ""

#: ../../types.md:53
msgid ""
"Imagine you add another line that tries to instantiate the defined class "
"using `SomeClass(\"23\")`. Mypy will catch that error for you:"
msgstr ""

#: ../../types.md:61
msgid "This happens *without* running your code!"
msgstr ""

#: ../../types.md:63
msgid ""
"And it also works with *both* Python 2-style annotation styles. To "
"*Mypy*, this code is equivalent to the one above:"
msgstr ""

#: ../../types.md:74
msgid "Pyright"
msgstr ""

#: ../../types.md:76
msgid ""
"*attrs* provides support for [*Pyright*] though the "
"[`dataclass_transform`] specification. This provides static type "
"inference for a subset of *attrs* equivalent to standard-library "
"{mod}`dataclasses`, and requires explicit type annotations using the "
"{func}`attrs.define` or `@attr.s(auto_attribs=True)` API."
msgstr ""

#: ../../types.md:80
msgid ""
"Given the following definition, *Pyright* will generate static type "
"signatures for `SomeClass` attribute access, `__init__`, `__eq__`, and "
"comparison methods:"
msgstr ""

#: ../../types.md:90
msgid ""
"The *Pyright* inferred types are a tiny subset of those supported by "
"*Mypy*, including:"
msgstr ""

#: ../../types.md:92
msgid ""
"The generated `__init__` signature only includes the attribute type "
"annotations. It currently does not include attribute `converter` types."
msgstr ""

#: ../../types.md:95
msgid ""
"The `attrs.frozen` decorator is not typed with frozen attributes, which "
"are properly typed via `attrs.define(frozen=True)`."
msgstr ""

#: ../../types.md:97
msgid ""
"A [full "
"list](https://github.com/microsoft/pyright/blob/main/specs/dataclass_transforms.md#attrs)"
" of limitations and incompatibilities can be found in *Pyright*'s "
"repository."
msgstr ""

#: ../../types.md:99
msgid ""
"Your constructive feedback is welcome in both "
"[attrs#795](https://github.com/python-attrs/attrs/issues/795) and "
"[pyright#1782](https://github.com/microsoft/pyright/discussions/1782). "
"Generally speaking, the decision on improving *attrs* support in "
"*Pyright* is entirely Microsoft's prerogative, though."
msgstr ""

