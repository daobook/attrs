# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../init.md:1
msgid "Initialization"
msgstr "初始化"

#: ../../init.md:3
msgid ""
"In Python, instance initialization happens in the `__init__` method. "
"Generally speaking, you should keep as little logic as possible in it, "
"and you should think about what the class needs and not how it is going "
"to be instantiated."
msgstr ""
"在 Python 中，实例初始化发生在 `__init__` 方法中。"
"一般来说，你应该尽可能少地保留其中的逻辑，你应该考虑类需要什么，而不是它将如何被实例化。"

#: ../../init.md:6
msgid ""
"Passing complex objects into `__init__` and then using them to derive "
"data for the class unnecessarily couples your new class with the old "
"class which makes it harder to test and also will cause problems later."
msgstr ""
"将复杂的对象传入 `__init__`，然后使用它们为类派生数据，不必要地将新类与旧类耦合起来，这使得测试更加困难，也会在以后引起问题。"

#: ../../init.md:8
msgid ""
"So assuming you use an ORM and want to extract 2D points from a row "
"object, do not write code like this:"
msgstr ""
"所以假设你使用 ORM 并想要从行对象中提取 2D 点，不要写这样的代码："

#: ../../init.md:19
msgid "Instead, write a {obj}`classmethod` that will extract it for you:"
msgstr "而是，写 {obj}`classmethod` 来为你提取它："

#: ../../init.md:34
msgid ""
"Now you can instantiate `Point`s without creating fake row objects in "
"your tests and you can have as many smart creation helpers as you want, "
"in case more data sources appear."
msgstr ""
"现在，您可以实例化 `Point`，而不必在测试中创建虚假的行对象，并且您可以拥有尽可能多的智能创建帮助程序，以防出现更多数据源。"

#: ../../init.md:36
msgid "For similar reasons, we strongly discourage from patterns like:"
msgstr "出于类似的原因，强烈反对使用以下模式："

#: ../../init.md:42
msgid ""
"which couples your classes to the database data model. Try to design your"
" classes in a way that is clean and convenient to use -- not based on "
"your database format. The database format can change anytime and you're "
"stuck with a bad class design that is hard to change. Embrace functions "
"and classmethods as a filter between reality and what's best for you to "
"work with."
msgstr ""
"它将您的类与数据库数据模型耦合。尝试以一种干净和方便使用的方式设计你的类——而不是基于你的数据库格式。"
"数据库的格式随时都可能改变，你会陷入一个很难改变的糟糕的类设计中。把函数和类方法作为现实和最适合你的工作之间的过滤器。"

#: ../../init.md:48
msgid ""
"While *attrs*'s initialization concepts (including the following sections"
" about validators and converters) are powerful, they are **not** intended"
" to replace a fully-featured serialization or validation system."
msgstr ""
"虽然 *attrs* 的初始化概念(包括下面关于验证器和转换器的部分)功能强大，但它们并不打算取代功能齐全的序列化或验证系统。"

#: ../../init.md:50
msgid ""
"We want to help you to write a `__init__` that you'd write by hand, but "
"with less boilerplate."
msgstr ""
"我们想帮助你写 `__init__`，你会手写，但有更少的样板文件。"

#: ../../init.md:52
msgid ""
"If you look for powerful-yet-unintrusive serialization and validation for"
" your *attrs* classes, have a look at our sibling project "
"[*cattrs*](https://catt.rs/) or our [third-party "
"extensions](https://github.com/python-attrs/attrs/wiki/Extensions-to-"
"attrs)."
msgstr ""
"如果您正在为您的 *attrs* 类寻找强大而非侵入式的序列化和验证，请查看兄弟项目 [*cattrs*](https://catt.rs/) 或"
"[第三方扩展](https://github.com/python-attrs/attrs/wiki/Extensions-to-attrs)。"

#: ../../init.md:57
msgid "Private Attributes and Aliases"
msgstr "私有属性和别名"

#: ../../init.md:59
msgid ""
"One thing people tend to find confusing is the treatment of private "
"attributes that start with an underscore. *attrs* follows the doctrine "
"that [there is no such thing as a private "
"argument](https://github.com/hynek/characteristic/issues/6) and strips "
"the underscores from the name when writing the `__init__` method "
"signature:"
msgstr ""
"人们容易感到困惑的一件事是如何处理以下划线开头的私有属性。"
"*attrs* 遵循这样的原则，即[没有私有参数](https://github.com/hynek/characteristic/issues/6)，"
"并在编写 `__init__` 方法签名时从名称中去掉下划线："

#: ../../init.md:72
msgid ""
"There really isn't a right or wrong, it's a matter of taste. But it's "
"important to be aware of it because it can lead to surprising syntax "
"errors:"
msgstr ""
"这真的没有对错之分，只是趣味的问题。但注意它很重要，因为它可能会导致令人惊讶的语法错误："

#: ../../init.md:84
msgid ""
"In this case a valid attribute name `_1` got transformed into an invalid "
"argument name `1`."
msgstr ""
"在这种情况下，有效的属性名 `_1` 被转换为无效的参数名 `1`。"

#: ../../init.md:86
msgid ""
"If your taste differs, you can use the *alias* argument to "
"{func}`attrs.field` to explicitly set the argument name. This can be used"
" to override private attribute handling, or make other arbitrary changes "
"to `__init__` argument names."
msgstr ""
"如果您的喜好不同，您可以使用 {func}`attrs.field` 的 *alias* 参数来显式地设置参数名。"
"这可以用来覆盖私有属性处理，或对 `__init__` 参数名进行其他任意更改。"

#: ../../init.md:100
msgid "Defaults"
msgstr "默认值"

#: ../../init.md:102
msgid ""
"Sometimes you don't want to pass all attribute values to a class. And "
"sometimes, certain attributes aren't even intended to be passed but you "
"want to allow for customization anyways for easier testing."
msgstr ""
"有时候你不想把所有属性值都传递给类。有时，某些属性甚至不打算传递，但你希望允许自定义，以便更容易测试。"

#: ../../init.md:105
msgid "This is when default values come into play:"
msgstr "这就是默认值发挥作用的时候："

#: ../../init.md:122
msgid ""
"It's important that the decorated method -- or any other method or "
"property! -- doesn't have the same name as the attribute, otherwise it "
"would overwrite the attribute definition."
msgstr ""
"重要的是，装饰方法——或任何其他方法或属性！——不能与属性同名，否则会覆盖属性定义。"

#: ../../init.md:124
msgid ""
"Please note that as with function and method signatures, `default=[]` "
"will *not* do what you may think it might do:"
msgstr ""
"请注意，与函数和方法签名一样，`default=[]` 不会做你可能认为它可能做的事情："

#: ../../init.md:137
msgid "This is why *attrs* comes with factory options."
msgstr "这就是为什么 *attrs* 带有工厂选项。"

#: ../../init.md:140
msgid ""
"Please note that the decorator based defaults have one gotcha: they are "
"executed when the attribute is set, that means depending on the order of "
"attributes, the `self` object may not be fully initialized when they're "
"called."
msgstr ""
"请注意，基于装饰器的默认值有一个问题：它们在设置属性时执行，这意味着根据属性的顺序，`self` 对象在被调用时可能没有完全初始化。"

#: ../../init.md:143
msgid "Therefore you should use `self` as little as possible."
msgstr "因此，你应该尽量少用 `self`。"

#: ../../init.md:145
msgid ""
"Even the smartest of us can [get confused](https://github.com/python-"
"attrs/attrs/issues/289) by what happens if you pass partially initialized"
" objects around."
msgstr ""
"即使是最聪明的人也会对传递部分初始化的对象所发生的情况感到[困惑](https://github.com/python-attrs/attrs/issues/289)。"

#: ../../init.md:150
msgid "Validators"
msgstr "验证器"

#: ../../init.md:152
msgid ""
"Another thing that definitely *does* belong in `__init__` is checking the"
" resulting instance for invariants. This is why *attrs* has the concept "
"of validators."
msgstr ""
"另一件肯定属于 `__init__` 的事情是检查结果实例中的不变量。这就是为什么 *attrs* 有验证器的概念。"

#: ../../init.md:156
msgid "Decorator"
msgstr "装饰器"

#: ../../init.md:158
msgid ""
"The most straightforward way is using the attribute's `validator` method "
"as a decorator."
msgstr ""
"最直接的方法是使用属性的 `validator` 方法作为装饰器。"

#: ../../init.md:160
msgid "The method has to accept three arguments:"
msgstr "该方法必须接受三个参数："

#: ../../init.md:162
msgid "the *instance* that's being validated (aka `self`),"
msgstr "被验证的 *instance* (又名 `self`)"

#: ../../init.md:163
msgid "the *attribute* that it's validating, and finally"
msgstr "它正在验证的 *attribute*，最后"

#: ../../init.md:164
msgid "the *value* that is passed for it."
msgstr "传递给它的 *value*。"

#: ../../init.md:166
msgid ""
"These values are passed as *positional arguments*, therefore their names "
"don't matter."
msgstr ""
"这些值作为位置参数传递，因此它们的名称无关紧要。"

#: ../../init.md:168
msgid ""
"If the value does not pass the validator's standards, it just raises an "
"appropriate exception."
msgstr ""
"如果值没有通过验证器的标准，就会引发适当的异常。"

#: ../../init.md:186
msgid ""
"Again, it's important that the decorated method doesn't have the same "
"name as the attribute and that the {func}`attrs.field` helper is used."
msgstr ""
"同样重要的是，修饰过的方法没有与属性相同的名称，并且使用了 {func}`attrs.field` 辅助器。"

#: ../../init.md:189
msgid "Callables"
msgstr "回调"

#: ../../init.md:191
msgid ""
"If you want to re-use your validators, you should have a look at the "
"`validator` argument to {func}`attrs.field`."
msgstr ""
"如果希望重用验证器，应该查看 {func}`attrs.field` 的验证器参数。"

#: ../../init.md:193
msgid ""
"It takes either a callable or a list of callables (usually functions) and"
" treats them as validators that receive the same arguments as with the "
"decorator approach. Also as with the decorator approach, they are passed "
"as *positional arguments* so you can name them however you want."
msgstr ""
"它接受一个可调用对象或一组可调用对象(通常是函数)，并将它们视为与装饰器方法接收相同参数的验证器。"
"同样，与装饰器方法一样，它们作为位置参数传递，因此您可以随心所欲地命名它们。"

#: ../../init.md:196
msgid ""
"Since the validators run *after* the instance is initialized, you can "
"refer to other attributes while validating:"
msgstr ""
"由于验证器在实例初始化后运行，所以在验证时可以引用其他属性："

#: ../../init.md:216
msgid ""
"This example also shows of some syntactic sugar for using the "
"{obj}`attrs.validators.and_` validator: if you pass a list, all "
"validators have to pass."
msgstr ""
"这个例子还展示了使用 {obj}`attrs.validators.and_` 的一些语法技巧，如果你传递列表，所有的验证器都必须通过。"

#: ../../init.md:218
msgid ""
"*attrs* won't intercept your changes to those attributes but you can "
"always call {func}`attrs.validate` on any instance to verify that it's "
"still valid: When using {func}`attrs.define` or "
"[`attrs.frozen`](attrs.frozen), *attrs* will run the validators even when"
" setting the attribute."
msgstr ""
"*attrs* 不会拦截你对这些属性的更改，但你总是可以在任何实例上调用 {func}`attrs.validate` 来验证它仍然有效："
"当使用 {func}`attrs.define` 或 [`attrs.frozen`](attrs.frozen) 时，*attrs* 即使在设置属性时也会运行验证器。"

#: ../../init.md:229
msgid ""
"*attrs* ships with a bunch of validators, make sure to [check them out]( "
"api-validators) before writing your own:"
msgstr ""
"*attrs* 附带了一堆验证器，在编写自己的验证器之前一定要[检查它们](api-validators)："

#: ../../init.md:243
msgid ""
"Of course you can mix and match the two approaches at your convenience. "
"If you define validators both ways for an attribute, they are both ran:"
msgstr ""
"当然，你可以在方便的时候混合搭配这两种方法。"
"如果你用两种方式为一个属性定义验证器，它们都会被运行："

#: ../../init.md:266
msgid "And finally you can disable validators globally:"
msgstr "最后，你可以全局禁用验证器："

#: ../../init.md:279
msgid "You can achieve the same by using the context manager:"
msgstr "你可以通过使用上下文管理器来达到同样的效果："

#: ../../init.md:293
msgid "Converters"
msgstr "转换器"

#: ../../init.md:295
msgid ""
"Finally, sometimes you may want to normalize the values coming in. For "
"that *attrs* comes with converters."
msgstr ""

#: ../../init.md:298
msgid ""
"Attributes can have a `converter` function specified, which will be "
"called with the attribute's passed-in value to get a new value to use. "
"This can be useful for doing type-conversions on values that you don't "
"want to force your callers to do."
msgstr ""

#: ../../init.md:310
msgid ""
"Converters are run *before* validators, so you can use validators to "
"check the final form of the value."
msgstr ""

#: ../../init.md:328
msgid "Arguably, you can abuse converters as one-argument validators:"
msgstr ""

#: ../../init.md:337
msgid ""
"If a converter's first argument has a type annotation, that type will "
"appear in the signature for `__init__`. A converter will override an "
"explicit type annotation or `type` argument."
msgstr ""

#: ../../init.md:351
msgid "Hooking Yourself Into Initialization"
msgstr ""

#: ../../init.md:353
msgid ""
"Generally speaking, the moment you think that you need finer control over"
" how your class is instantiated than what *attrs* offers, it's usually "
"best to use a {obj}`classmethod` factory or to apply the [builder "
"pattern](https://en.wikipedia.org/wiki/Builder_pattern)."
msgstr ""

#: ../../init.md:355
msgid ""
"However, sometimes you need to do that one quick thing before or after "
"your class is initialized. And for that *attrs* offers three means:"
msgstr ""

#: ../../init.md:358
msgid ""
"`__attrs_pre_init__` is automatically detected and run *before* *attrs* "
"starts initializing. This is useful if you need to inject a call to "
"`super().__init__()`."
msgstr ""

#: ../../init.md:361
msgid ""
"`__attrs_post_init__` is automatically detected and run *after* *attrs* "
"is done initializing your instance. This is useful if you want to derive "
"some attribute from others or perform some kind of validation over the "
"whole instance."
msgstr ""

#: ../../init.md:364
msgid ""
"`__attrs_init__` is written and attached to your class *instead* of "
"`__init__`, if *attrs* is told to not write one (i.e. `init=False` or a "
"combination of `auto_detect=True` and a custom `__init__`). This is "
"useful if you want full control over the initialization process, but "
"don't want to set the attributes by hand."
msgstr ""

#: ../../init.md:368
msgid "Pre Init"
msgstr ""

#: ../../init.md:370
msgid ""
"The sole reason for the existence of `__attrs_pre_init__` is to give "
"users the chance to call `super().__init__()`, because some subclassing-"
"based APIs require that."
msgstr ""

#: ../../init.md:382
msgid "If you need more control, use the custom init approach described next."
msgstr ""

#: ../../init.md:385
msgid "Custom Init"
msgstr ""

#: ../../init.md:387
msgid ""
"If you tell *attrs* to not write an `__init__`, it will write an "
"`__attrs_init__` instead, with the same code that it would have used for "
"`__init__`. You have full control over the initialization, but also have "
"to type out the types of your arguments etc. Here's an example of a "
"manual default value:"
msgstr ""

#: ../../init.md:403
msgid "Post Init"
msgstr ""

#: ../../init.md:416
msgid "Please note that you can't directly set attributes on frozen classes:"
msgstr ""

#: ../../init.md:431
msgid ""
"If you need to set attributes on a frozen class, you'll have to resort to"
" the [same trick](how-frozen) as *attrs* and use "
"{meth}`object.__setattr__`:"
msgstr ""

#: ../../init.md:444
msgid ""
"Note that you *must not* access the hash code of the object in "
"`__attrs_post_init__` if `cache_hash=True`."
msgstr ""

#: ../../init.md:447
msgid "Order of Execution"
msgstr ""

#: ../../init.md:449
msgid "If present, the hooks are executed in the following order:"
msgstr ""

#: ../../init.md:451
msgid "`__attrs_pre_init__` (if present on *current* class)"
msgstr ""

#: ../../init.md:453
msgid "For each attribute, in the order it was declared:"
msgstr ""

#: ../../init.md:455
msgid "default factory"
msgstr ""

#: ../../init.md:456
msgid "converter"
msgstr ""

#: ../../init.md:458
msgid "*all* validators"
msgstr ""

#: ../../init.md:460
msgid "`__attrs_post_init__` (if present on *current* class)"
msgstr ""

#: ../../init.md:462
msgid ""
"Notably this means, that you can access all attributes from within your "
"validators, but your converters have to deal with invalid values and have"
" to return a valid value."
msgstr ""

#: ../../init.md:465
msgid "Derived Attributes"
msgstr ""

#: ../../init.md:467
msgid ""
"One of the most common *attrs* questions on *Stack Overflow* is how to "
"have attributes that depend on other attributes. For example if you have "
"an API token and want to instantiate a web client that uses it for "
"authentication. Based on the previous sections, there are two approaches."
msgstr ""

#: ../../init.md:471
msgid "The simpler one is using `__attrs_post_init__`:"
msgstr ""

#: ../../init.md:483
msgid "The second one is using a decorator-based default:"
msgstr ""

#: ../../init.md:496
msgid ""
"That said, and as pointed out in the beginning of the chapter, a better "
"approach would be to have a factory class method:"
msgstr ""

#: ../../init.md:508
msgid "This makes the class more testable."
msgstr ""

