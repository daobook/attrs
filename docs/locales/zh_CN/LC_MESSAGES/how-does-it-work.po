# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../how-does-it-work.md:3
msgid "How Does It Work?"
msgstr ""

#: ../../how-does-it-work.md:5
msgid "Boilerplate"
msgstr ""

#: ../../how-does-it-work.md:7
msgid ""
"*attrs* isn't the first library that aims to simplify class definition in"
" Python. But its **declarative** approach combined with **no runtime "
"overhead** lets it stand out."
msgstr ""

#: ../../how-does-it-work.md:10
msgid ""
"Once you apply the `@attrs.define` (or `@attr.s`) decorator to a class, "
"*attrs* searches the class object for instances of `attr.ib`s. Internally"
" they're a representation of the data passed into `attr.ib` along with a "
"counter to preserve the order of the attributes. Alternatively, it's "
"possible to define them using {doc}`types`."
msgstr ""

#: ../../how-does-it-work.md:14
msgid ""
"In order to ensure that subclassing works as you'd expect it to work, "
"*attrs* also walks the class hierarchy and collects the attributes of all"
" base classes. Please note that *attrs* does *not* call `super()` *ever*."
" It will write {term}`dunder methods` to work on *all* of those "
"attributes which also has performance benefits due to fewer function "
"calls."
msgstr ""

#: ../../how-does-it-work.md:18
msgid ""
"Once *attrs* knows what attributes it has to work on, it writes the "
"requested {term}`dunder methods` and -- depending on whether you wish to "
"have a {term}`dict <dict classes>` or {term}`slotted <slotted classes>` "
"class -- creates a new class for you (`slots=True`) or attaches them to "
"the original class (`slots=False`). While creating new classes is more "
"elegant, we've run into several edge cases surrounding metaclasses that "
"make it impossible to go this route unconditionally."
msgstr ""

#: ../../how-does-it-work.md:21
msgid ""
"To be very clear: if you define a class with a single attribute without a"
" default value, the generated `__init__` will look *exactly* how you'd "
"expect:"
msgstr ""

#: ../../how-does-it-work.md:35
msgid "No magic, no meta programming, no expensive introspection at runtime."
msgstr ""

#: ../../how-does-it-work.md:39
msgid ""
"Everything until this point happens exactly *once* when the class is "
"defined. As soon as a class is done, it's done. And it's just a regular "
"Python class like any other, except for a single `__attrs_attrs__` "
"attribute that *attrs* uses internally. Much of the information is "
"accessible via {func}`attrs.fields` and other functions which can be used"
" for introspection or for writing your own tools and decorators on top of"
" *attrs* (like {func}`attrs.asdict`)."
msgstr ""

#: ../../how-does-it-work.md:44
msgid ""
"And once you start instantiating your classes, *attrs* is out of your way"
" completely."
msgstr ""

#: ../../how-does-it-work.md:46
msgid ""
"This **static** approach was very much a design goal of *attrs* and what "
"I strongly believe makes it distinct."
msgstr ""

#: ../../how-does-it-work.md:50
msgid "Immutability"
msgstr ""

#: ../../how-does-it-work.md:52
msgid ""
"In order to give you immutability, *attrs* will attach a `__setattr__` "
"method to your class that raises an "
"{class}`attrs.exceptions.FrozenInstanceError` whenever anyone tries to "
"set an attribute."
msgstr ""

#: ../../how-does-it-work.md:54
msgid ""
"The same is true if you choose to freeze individual attributes using the "
"{obj}`attrs.setters.frozen` *on_setattr* hook -- except that the "
"exception becomes {class}`attrs.exceptions.FrozenAttributeError`."
msgstr ""

#: ../../how-does-it-work.md:56
msgid "Both exceptions subclass {class}`attrs.exceptions.FrozenError`."
msgstr ""

#: ../../how-does-it-work.md:60
msgid ""
"Depending on whether a class is a dict class or a slotted class, *attrs* "
"uses a different technique to circumvent that limitation in the "
"`__init__` method."
msgstr ""

#: ../../how-does-it-work.md:62
msgid ""
"Once constructed, frozen instances don't differ in any way from regular "
"ones except that you cannot change its attributes."
msgstr ""

#: ../../how-does-it-work.md:64
msgid "Dict Classes"
msgstr ""

#: ../../how-does-it-work.md:66
msgid ""
"Dict classes -- i.e. regular classes -- simply assign the value directly "
"into the class' eponymous `__dict__` (and there's nothing we can do to "
"stop the user to do the same)."
msgstr ""

#: ../../how-does-it-work.md:68
msgid "The performance impact is negligible."
msgstr ""

#: ../../how-does-it-work.md:70
msgid "Slotted Classes"
msgstr ""

#: ../../how-does-it-work.md:72
msgid ""
"Slotted classes are more complicated. Here it uses (an aggressively "
"cached) {meth}`object.__setattr__` to set your attributes. This is "
"(still) slower than a plain assignment:"
msgstr ""

#: ../../how-does-it-work.md:90
msgid ""
"So on a laptop computer the difference is about 200 nanoseconds (1 second"
" is 1,000,000,000 nanoseconds). It's certainly something you'll feel in a"
" hot loop but shouldn't matter in normal code. Pick what's more important"
" to you."
msgstr ""

#: ../../how-does-it-work.md:94
msgid "Summary"
msgstr ""

#: ../../how-does-it-work.md:96
msgid ""
"You should avoid instantiating lots of frozen slotted classes (i.e. "
"`@frozen`) in performance-critical code."
msgstr ""

#: ../../how-does-it-work.md:98
msgid ""
"Frozen dict classes have barely a performance impact, unfrozen slotted "
"classes are even *faster* than unfrozen dict classes (i.e. regular "
"classes)."
msgstr ""

