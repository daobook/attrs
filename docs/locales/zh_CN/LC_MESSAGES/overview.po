# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# xinetzone <xinzone@outlook.com>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../overview.md:1
msgid "Overview"
msgstr "概述"

#: ../../overview.md:3
msgid ""
"In order to fulfill its ambitious goal of bringing back the joy to "
"writing classes, it gives you a class decorator and a way to "
"declaratively define the attributes on that class:"
msgstr ""
"为了实现重拾编写类的乐趣这一雄心勃勃的目标，它提供了类装饰器和声明式定义类属性的方法："

#: ../../../README.md:3464
msgid "After *declaring* your attributes, *attrs* gives you:"
msgstr "在 *declaring* 你的属性后，*attrs* 给你："

#: ../../../README.md:3466
msgid "a concise and explicit overview of the class's attributes,"
msgstr "简洁而显式的类属性概述，"

#: ../../../README.md:3467
msgid "a nice human-readable `__repr__`,"
msgstr "良好的人类可读的 `__repr__`，"

#: ../../../README.md:3468
msgid "equality-checking methods,"
msgstr "equality-checking 方法，"

#: ../../../README.md:3469
msgid "an initializer,"
msgstr "初始化器"

#: ../../../README.md:3470
msgid "and much more,"
msgstr "还有更多，"

#: ../../../README.md:3472
msgid ""
"*without* writing dull boilerplate code again and again and *without* "
"runtime performance penalties."
msgstr ""
"不用一遍又一遍地编写乏味的样板代码，也不会对运行时性能造成影响。"

#: ../../../README.md:3474
msgid ""
"**Hate type annotations**!? No problem! Types are entirely **optional** "
"with *attrs*. Simply assign `attrs.field()` to the attributes instead of "
"annotating them with types."
msgstr ""
"讨厌文字注释!?没问题!类型在 *attrs* 中是完全可选的。只需将 `attrs.field()` 分配给属性，而不是用类型注释它们。"

#: ../../../README.md:3481
msgid ""
"This example uses *attrs*'s modern APIs that have been introduced in "
"version 20.1.0, and the *attrs* package import name that has been added "
"in version 21.3.0. The classic APIs (`@attr.s`, `attr.ib`, plus their "
"serious-business aliases) and the `attr` package import name will remain "
"**indefinitely**."
msgstr ""
"这个例子使用了 20.1.0 版本中引入的 *attrs* 现代 api，以及 21.3.0 版本中添加的 *attrs* 包导入名称。"
"经典的 api (`@attr.s`，`attr.ib`，加上他们的 serious-business 别名）和 `attr` 包导入名称将无限期保留。"

#: ../../../README.md:3484
msgid ""
"Please check out [*On The Core API "
"Names*](https://www.attrs.org/en/latest/names.html) for a more in-depth "
"explanation."
msgstr ""
"请查看[*On The Core API Names*](https://www.attrs.org/en/latest/names.html)以获得更深入的解释。"

#: ../../../README.md:3487
msgid "Data Classes"
msgstr "数据类"

#: ../../../README.md:3489
msgid ""
"On the tin, *attrs* might remind you of `dataclasses` (and indeed, "
"`dataclasses` [are a descendant](https://hynek.me/articles/import-attrs/)"
" of *attrs*). In practice it does a lot more and is more flexible. For "
"instance it allows you to define [special handling of NumPy arrays for "
"equality "
"checks](https://www.attrs.org/en/stable/comparison.html#customization), "
"or allows more ways to [plug into the initialization "
"process](https://www.attrs.org/en/stable/init.html#hooking-yourself-into-"
"initialization)."
msgstr ""
"总的来说，*attrs* 可能会让您想起 `dataclasses` （事实上，`dataclasses` 是 [*attrs* 的后代](https://hynek.me/articles/import-attrs/)）。"
"在实践中，它做得更多，也更灵活。"
"例如，它允许您为[相等性检查定义 NumPy 数组的特殊处理](https://www.attrs.org/en/stable/comparison.html#customization)，"
"或者允许更多方法插入[初始化过程](https://www.attrs.org/en/stable/init.html#hooking-yourself-into-initialization)。"

#: ../../../README.md:3493
msgid ""
"For more details, please refer to our [comparison "
"page](https://www.attrs.org/en/stable/why.html#data-classes)."
msgstr ""
"更多详情请参考我们的[比较页面](https://www.attrs.org/en/stable/why.html#data-classes)。"

#: ../../overview.md:11
msgid "Philosophy"
msgstr "哲学"

#: ../../overview.md:13
msgid "**It's about regular classes.**"
msgstr ""

#: ../../overview.md:15
msgid ""
"*attrs* is for creating well-behaved classes with a type, attributes, "
"methods, and everything that comes with a class. It can be used for data-"
"only containers like `namedtuple`s or `types.SimpleNamespace` but they're"
" just a sub-genre of what *attrs* is good for."
msgstr ""
"*attrs* 用于创建具有类型、属性、方法以及类所附带的一切的行为良好的类。"
"它可以用于只有数据的容器，如 `namedtuple` 或 `types.SimpleNamespace`，但它们只是 *attrs* 所擅长的子类型。"

#: ../../overview.md:19
msgid "**The class belongs to the users.**"
msgstr "**类属于用户。**"

#: ../../overview.md:21
msgid ""
"You define a class and *attrs* adds static methods to that class based on"
" the attributes you declare. The end. It doesn't add metaclasses. It "
"doesn't add classes you've never heard of to your inheritance tree. An "
"*attrs* class in runtime is indistinguishable from a regular class: "
"because it *is* a regular class with a few boilerplate-y methods "
"attached."
msgstr ""
"定义类，*attrs* 根据您声明的属性向该类添加静态方法。"
"最后。它不添加元类。它不会将您从未听说过的类添加到继承树中。"
"运行时的 *attrs* 类与常规类没有区别：因为它是附加了一些样板方法的常规类。"

#: ../../overview.md:28
msgid "**Be light on API impact.**"
msgstr "**对API影响要轻。**"

#: ../../overview.md:30
msgid ""
"As convenient as it seems at first, *attrs* will *not* tack on any "
"methods to your classes except for the {term}`dunder ones <dunder "
"methods>`. Hence all the useful [tools](helpers) that come with *attrs* "
"live in functions that operate on top of instances. Since they take an "
"*attrs* instance as their first argument, you can attach them to your "
"classes with one line of code."
msgstr ""
"虽然乍一看很方便，但 *attrs* 不会为你的类附加任何方法，除了那些 {term}`dunder 的方法 <dunder methods>`。"
"因此，*attrs* 附带的所有有用 [tools](helpers) 都存在于在实例之上操作的函数中。"
"由于它们将 *attrs* 实例作为第一个参数，您可以用一行代码将它们附加到类中。"

#: ../../overview.md:35
msgid "**Performance matters.**"
msgstr "**影响性能的事项。**"

#: ../../overview.md:37
msgid ""
"*attrs* runtime impact is very close to zero because all the work is done"
" when the class is defined. Once you're instantiating it, *attrs* is out "
"of the picture completely."
msgstr ""
"*attrs* 的运行时影响非常接近于零，因为所有的工作都是在定义类时完成的。一旦实例化了它，*attrs* 就完全消失了。"

#: ../../overview.md:41
msgid "**No surprises.**"
msgstr "**怡然自得。**"

#: ../../overview.md:43
msgid ""
"*attrs* creates classes that arguably work the way a Python beginner "
"would reasonably expect them to work. It doesn't try to guess what you "
"mean because explicit is better than implicit. It doesn't try to be "
"clever because software shouldn't be clever."
msgstr ""
"*attrs* 创建的类可以按照 Python 初学者合理期望的方式工作。"
"它不会试图猜测你的意思，因为显式比隐式好。它并不试图变得聪明，因为软件不应该变得聪明。"

#: ../../overview.md:47
msgid ""
"Check out {doc}`how-does-it-work` if you'd like to know how it achieves "
"all of the above."
msgstr ""
"看看{doc}`how-does-it-work`，如果你想知道它是如何实现以上所有目标的。"

#: ../../overview.md:50
msgid "What *attrs* Is Not"
msgstr "什么是 *attrs* 没有做的"

#: ../../overview.md:52
msgid ""
"*attrs* does *not* invent some kind of magic system that pulls classes "
"out of its hat using meta classes, runtime introspection, and shaky "
"interdependencies."
msgstr ""
"*attrs* 并没有发明某种神奇的系统，使用元类、运行时内省和不稳定的相互依赖性来实现类。"

#: ../../overview.md:54
msgid "All *attrs* does is:"
msgstr "所有 *attrs* 做的是："

#: ../../overview.md:56
msgid "Take your declaration,"
msgstr ""

#: ../../overview.md:57
msgid "write {term}`dunder methods` based on that information,"
msgstr ""

#: ../../overview.md:58
msgid "and attach them to your class."
msgstr ""

#: ../../overview.md:60
msgid ""
"It does *nothing* dynamic at runtime, hence zero runtime overhead. It's "
"still *your* class. Do with it as you please."
msgstr ""
"它在运行时不做任何动态操作，因此运行时开销为零。这仍然是你的类。你想怎么处置就怎么处置。"
