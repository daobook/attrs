# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, Hynek Schlawack
# This file is distributed under the same license as the attrs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: attrs 22.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-01-10 12:37+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../glossary.md:1
msgid "Glossary"
msgstr ""

#: ../../glossary.md
msgid "dunder methods"
msgstr ""

#: ../../glossary.md:5
msgid "\"Dunder\" is a contraction of \"double underscore\"."
msgstr ""

#: ../../glossary.md:7
msgid ""
"It's methods like `__init__` or `__eq__` that are sometimes also called "
"*magic methods* or it's said that they implement an *object protocol*."
msgstr ""

#: ../../glossary.md:9
msgid "In spoken form, you'd call `__init__` just \"dunder init\"."
msgstr ""

#: ../../glossary.md:11
msgid ""
"Its first documented use is a [mailing list "
"posting](https://mail.python.org/pipermail/python-"
"list/2002-September/155836.html) by Mark Jackson from 2002."
msgstr ""

#: ../../glossary.md:9
msgid "dict classes"
msgstr ""

#: ../../glossary.md:14
msgid ""
"A regular class whose attributes are stored in the "
"{attr}`object.__dict__` attribute of every single instance. This is quite"
" wasteful especially for objects with very few data attributes and the "
"space consumption can become significant when creating large numbers of "
"instances."
msgstr ""

#: ../../glossary.md:17
msgid ""
"This is the type of class you get by default both with and without "
"*attrs* (except with the next APIs {func}`attrs.define()`, "
"[`attrs.mutable()`](attrs.mutable), and "
"[`attrs.frozen()`](attrs.frozen))."
msgstr ""

#: ../../glossary.md:15
msgid "slotted classes"
msgstr ""

#: ../../glossary.md:20
msgid ""
"A class whose instances have no {attr}`object.__dict__` attribute and "
"[define](https://docs.python.org/3/reference/datamodel.html#slots) their "
"attributes in a `object.__slots__` attribute instead. In *attrs*, they "
"are created by passing `slots=True` to `@attr.s` (and are on by default "
"in {func}`attrs.define()`, [`attrs.mutable()`](attrs.mutable), and "
"[`attrs.frozen()`](attrs.frozen))."
msgstr ""

#: ../../glossary.md:23
msgid ""
"Their main advantage is that they use less memory on CPython[^pypy] and "
"are slightly faster."
msgstr ""

#: ../../glossary.md:25
msgid "However, they also come with several possibly surprising gotchas:"
msgstr ""

#: ../../glossary.md:27
msgid ""
"Slotted classes don't allow for any other attribute to be set except for "
"those defined in one of the class' hierarchies `__slots__`:"
msgstr ""

#: ../../glossary.md:43
msgid ""
"Slotted classes can inherit from other classes just like non-slotted "
"classes, but some of the benefits of slotted classes are lost if you do "
"that. If you must inherit from other classes, try to inherit only from "
"other slotted classes."
msgstr ""

#: ../../glossary.md:46
msgid ""
"However, [it's not "
"possible](https://docs.python.org/3/reference/datamodel.html#notes-on-"
"using-slots) to inherit from more than one class that has attributes in "
"`__slots__` (you will get an `TypeError: multiple bases have instance "
"lay-out conflict`)."
msgstr ""

#: ../../glossary.md:48
msgid ""
"It's not possible to monkeypatch methods on slotted classes. This can "
"feel limiting in test code, however the need to monkeypatch your own "
"classes is usually a design smell."
msgstr ""

#: ../../glossary.md:51
msgid ""
"If you really need to monkeypatch an instance in your tests, but don't "
"want to give up on the advantages of slotted classes in production code, "
"you can always subclass a slotted class as a dict class with no further "
"changes and all the limitations go away:"
msgstr ""

#: ../../glossary.md:79
msgid ""
"Slotted classes must implement {meth}`__getstate__ <object.__getstate__>`"
" and {meth}`__setstate__ <object.__setstate__>` to be serializable with "
"{mod}`pickle` protocol 0 and 1. Therefore, *attrs* creates these methods "
"automatically for slotted classes."
msgstr ""

#: ../../glossary.md:83
msgid ""
"When decorating with `@attr.s(slots=True)` and the class already "
"implements the {meth}`__getstate__ <object.__getstate__>` and "
"{meth}`__setstate__ <object.__setstate__>` methods, they will be "
"*overwritten* by *attrs* autogenerated implementation by default."
msgstr ""

#: ../../glossary.md:85
msgid ""
"This can be avoided by setting `@attr.s(getstate_setstate=False)` or by "
"setting `@attr.s(auto_detect=True)`."
msgstr ""

#: ../../glossary.md:87
msgid "{func}`~attrs.define` sets `auto_detect=True` by default."
msgstr ""

#: ../../glossary.md:90
msgid ""
"Also, [think twice](https://www.youtube.com/watch?v=7KnfGDajDQw) before "
"using {mod}`pickle`."
msgstr ""

#: ../../glossary.md:92
msgid ""
"Slotted classes are weak-referenceable by default. This can be disabled "
"in CPython by passing `weakref_slot=False` to `@attr.s` [^pypyweakref]."
msgstr ""

#: ../../glossary.md:95
msgid ""
"Since it's currently impossible to make a class slotted after it's been "
"created, *attrs* has to replace your class with a new one. While it tries"
" to do that as graciously as possible, certain metaclass features like "
"{meth}`object.__init_subclass__` do not work with slotted classes."
msgstr ""

#: ../../glossary.md:98
msgid ""
"The {attr}`class.__subclasses__` attribute needs a garbage collection run"
" (which can be manually triggered using {func}`gc.collect`), for the "
"original class to be removed. See issue [#407](https://github.com/python-"
"attrs/attrs/issues/407) for more details."
msgstr ""

#: ../../glossary.md:102
msgid "On PyPy, there is no memory advantage in using slotted classes."
msgstr ""

#: ../../glossary.md:104
msgid ""
"On PyPy, slotted classes are naturally weak-referenceable so "
"`weakref_slot=False` has no effect."
msgstr ""

